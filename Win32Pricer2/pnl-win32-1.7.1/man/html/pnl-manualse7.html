<?xml version="1.0" encoding="iso-8859-1" ?> 
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" 
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">  
<!--http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd-->  
<html xmlns="http://www.w3.org/1999/xhtml"  
> 
<head><title>Function bases and regression</title> 
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1" /> 
<meta name="generator" content="TeX4ht (http://www.tug.org/tex4ht/)" /> 
<meta name="originator" content="TeX4ht (http://www.tug.org/tex4ht/)" /> 
<!-- xhtml,uni-html4,2,subsection+,next,html --> 
<meta name="src" content="pnl-manual.tex" /> 
<meta name="date" content="2014-07-22 17:33:00" /> 
<link rel="stylesheet" type="text/css" href="pnl-manual.css" /> 
</head><body 
>
<!--l. 1--><div class="crosslinks"><p class="noindent">[<a 
href="pnl-manualse8.html" >next</a>] [<a 
href="pnl-manualse6.html" >prev</a>] [<a 
href="pnl-manualse6.html#tailpnl-manualse6.html" >prev-tail</a>] [<a 
href="#tailpnl-manualse7.html">tail</a>] [<a 
href="pnl-manual.html#pnl-manualse7.html" >up</a>] </p></div>
<h3 class="sectionHead"><span class="titlemark">7   </span> <a 
 id="x9-1020007"></a>Function bases and regression</h3>
<!--l. 2--><p class="noindent" >
</p>
<h4 class="subsectionHead"><span class="titlemark">7.1   </span> <a 
 id="x9-1030007.1"></a>Overview</h4>
<!--l. 4--><p class="noindent" >To use these functionalities, you should include <span class="obeylines-h"><span class="verb"><span 
class="ec-lmtt-10x-x-109">pnl/pnl_basis.h</span></span></span>.
<a 
 id="dx9-103001"></a>
                                                                                    

                                                                                    
</p>
<div class="verbatim" id="verbatim-37">
struct&#x00A0;PnlBasis_t&#x00A0;{
&#x00A0;<br />&#x00A0;&#x00A0;int&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;id;
&#x00A0;<br />&#x00A0;&#x00A0;const&#x00A0;char&#x00A0;&#x00A0;*label;&#x00A0;/*!&#x003C;&#x00A0;string&#x00A0;to&#x00A0;label&#x00A0;the&#x00A0;basis&#x00A0;*
&#x00A0;<br />&#x00A0;&#x00A0;int&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;nb_variates;&#x00A0;&#x00A0;/*!&#x003C;&#x00A0;number&#x00A0;of&#x00A0;variates&#x00A0;*
&#x00A0;<br />&#x00A0;&#x00A0;int&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;nb_func;&#x00A0;/*!&#x003C;&#x00A0;number&#x00A0;of&#x00A0;elements&#x00A0;in&#x00A0;the&#x00A0;basis&#x00A0;*
&#x00A0;<br />&#x00A0;&#x00A0;PnlMatInt&#x00A0;&#x00A0;&#x00A0;*T;&#x00A0;/*!&#x003C;&#x00A0;Tensor&#x00A0;matrix&#x00A0;*
&#x00A0;<br />&#x00A0;&#x00A0;PnlSpMatInt&#x00A0;*SpT;&#x00A0;/*!&#x003C;&#x00A0;Sparse&#x00A0;Tensor&#x00A0;matrix&#x00A0;*
&#x00A0;<br />&#x00A0;&#x00A0;double&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;(*f)(double&#x00A0;&#x00A0;&#x00A0;x,&#x00A0;int&#x00A0;i);&#x00A0;/*!&#x003C;&#x00A0;Computes&#x00A0;the&#x00A0;i-th&#x00A0;element
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;of&#x00A0;the&#x00A0;one&#x00A0;dimensional&#x00A0;basis&#x00A0;*/
&#x00A0;<br />&#x00A0;&#x00A0;double&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;(*Df)(double&#x00A0;&#x00A0;x,&#x00A0;int&#x00A0;i);&#x00A0;/*!&#x003C;&#x00A0;Computes&#x00A0;the&#x00A0;first&#x00A0;derivative
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;of&#x00A0;the&#x00A0;i-th&#x00A0;element&#x00A0;of&#x00A0;the&#x00A0;one&#x00A0;dimensional&#x00A0;basis&#x00A0;*/
&#x00A0;<br />&#x00A0;&#x00A0;double&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;(*D2f)(double&#x00A0;x,&#x00A0;int&#x00A0;i);&#x00A0;/*!&#x003C;&#x00A0;Computes&#x00A0;the&#x00A0;second&#x00A0;derivative
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;of&#x00A0;the&#x00A0;i-th&#x00A0;element&#x00A0;of&#x00A0;the&#x00A0;one&#x00A0;dimensional&#x00A0;basis&#x00A0;*/
&#x00A0;<br />&#x00A0;&#x00A0;int&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;isreduced;&#x00A0;/*&#x00A0;TRUE&#x00A0;if&#x00A0;the&#x00A0;basis&#x00A0;is&#x00A0;reduced&#x00A0;*/
&#x00A0;<br />&#x00A0;&#x00A0;double&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;*center;&#x00A0;/*!&#x003C;&#x00A0;center&#x00A0;of&#x00A0;the&#x00A0;domain&#x00A0;*/
&#x00A0;<br />&#x00A0;&#x00A0;double&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;*scale;&#x00A0;/*&#x003C;!&#x00A0;inverse&#x00A0;of&#x00A0;the&#x00A0;scaling&#x00A0;factor&#x00A0;to&#x00A0;map&#x00A0;the
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;domain&#x00A0;to&#x00A0;[-1,&#x00A0;1]^nb_variates&#x00A0;*/
&#x00A0;<br />};
</div>
<!--l. 26--><p class="nopar" >
</p><!--l. 28--><p class="noindent" >A multi-dimensional basis is built as a tensor product of one dimensional elements. Hence, we only
need a tensor matrix to describe a multi-dimensional basis in terms of the one dimensional one. The
two tensors <span class='var'>T</span> and <span class='var'>SpT</span> do actually store the same information &#8212; <span class='var'>T(i,j)</span> is the degree w.r.t the <span class='var'>j</span>-th
variable in the <span class='var'>i</span>-th function. Originally, we were only using the dense representation <span class='var'>T</span>, which is
far more convenient to use when building the basis but it slows down the evaluation of
the basis by a great deal. To overcome this lack of efficiency, a sparse storage has been
added.
</p>
<div class="table">
                                                                                    

                                                                                    
<!--l. 38--><p class="noindent" ><a 
 id="x9-1030053"></a></p><hr class="float" /><div class="float" 
>
                                                                                    

                                                                                    
<!--tex4ht:inline--><div class="tabular"> <table id="TBL-12" class="tabular" 
cellspacing="0" cellpadding="0"  
><colgroup id="TBL-12-1g"><col 
id="TBL-12-1" /><col 
id="TBL-12-2" /><col 
id="TBL-12-3" /></colgroup><tr  
 style="vertical-align:baseline;" id="TBL-12-1-"><td  style="white-space:nowrap; text-align:left;" id="TBL-12-1-1"  
class="td11"><a 
 id="dx9-103002"></a><span class='struct'>PNL_BASIS_CANONICAL</span>  </td><td  style="white-space:wrap; text-align:left;" id="TBL-12-1-2"  
class="td11"><!--l. 40--><p class="noindent" >     </p></td><td  style="white-space:nowrap; text-align:left;" id="TBL-12-1-3"  
class="td11">for the Canonical polynomials  </td>
</tr><tr  
 style="vertical-align:baseline;" id="TBL-12-2-"><td  style="white-space:nowrap; text-align:left;" id="TBL-12-2-1"  
class="td11"><a 
 id="dx9-103003"></a><span class='struct'>PNL_BASIS_HERMITE</span>       </td><td  style="white-space:wrap; text-align:left;" id="TBL-12-2-2"  
class="td11"><!--l. 41--><p class="noindent" >     </p></td><td  style="white-space:nowrap; text-align:left;" id="TBL-12-2-3"  
class="td11">for the Hermite polynomials     </td>
</tr><tr  
 style="vertical-align:baseline;" id="TBL-12-3-"><td  style="white-space:nowrap; text-align:left;" id="TBL-12-3-1"  
class="td11"><a 
 id="dx9-103004"></a><span class='struct'>PNL_BASIS_TCHEBYCHEV</span></td><td  style="white-space:wrap; text-align:left;" id="TBL-12-3-2"  
class="td11"><!--l. 42--><p class="noindent" >     </p></td><td  style="white-space:nowrap; text-align:left;" id="TBL-12-3-3"  
class="td11">for the Tchebychev polynomials</td>
</tr><tr  
 style="vertical-align:baseline;" id="TBL-12-4-"><td  style="white-space:nowrap; text-align:left;" id="TBL-12-4-1"  
class="td11">                          </td></tr></table></div>
 <div class="caption" 
><span class="id">Table&#x00A0;3: </span><span  
class="content">Names of the bases. See also function <a 
href="#x9-1040007.2">pnl_basis_type_register</a> to register more
basis types.</span></div><!--tex4ht:label?: x9-1030053 -->
                                                                                    

                                                                                    
</div><hr class="endfloat" />
</div>
<!--l. 49--><p class="noindent" >In this section, we provide functions to solve regression problems on finite dimensional bases. Let
<span 
class="rm-lmr-10x-x-109">(</span><span 
class="lmmi-10x-x-109">x</span><sub><span 
class="lmmi-8">i</span></sub><span 
class="lmmi-10x-x-109">,i </span><span 
class="rm-lmr-10x-x-109">= 1</span><span 
class="lmmi-10x-x-109">&#x2026;</span><span 
class="lmmi-10x-x-109">n</span><span 
class="rm-lmr-10x-x-109">) </span>be <span 
class="lmmi-10x-x-109">n </span>points in <span 
class="msbm-10x-x-109">&#x211D;</span><sup><span 
class="lmmi-8">d</span></sup> and a function <span 
class="lmmi-10x-x-109">g </span>defined by the data <span 
class="rm-lmr-10x-x-109">(</span><span 
class="lmmi-10x-x-109">y</span><sub><span 
class="lmmi-8">i</span></sub> <span 
class="rm-lmr-10x-x-109">= </span><span 
class="lmmi-10x-x-109">g</span><span 
class="rm-lmr-10x-x-109">(</span><span 
class="lmmi-10x-x-109">x</span><sub><span 
class="lmmi-8">i</span></sub><span 
class="rm-lmr-10x-x-109">)</span><span 
class="lmmi-10x-x-109">,i </span><span 
class="rm-lmr-10x-x-109">= 1</span><span 
class="lmmi-10x-x-109">&#x2026;</span><span 
class="lmmi-10x-x-109">n</span><span 
class="rm-lmr-10x-x-109">)</span>. Assume
you want to approximate the function <span 
class="lmmi-10x-x-109">g </span>by its decomposition on a family of <span 
class="lmmi-10x-x-109">N </span>functions
<span 
class="rm-lmr-10x-x-109">(</span><span 
class="lmmi-10x-x-109">f</span><sub><span 
class="lmmi-8">j</span></sub><span 
class="lmmi-10x-x-109">,j </span><span 
class="rm-lmr-10x-x-109">= 1</span><span 
class="lmmi-10x-x-109">&#x2026;</span><span 
class="lmmi-10x-x-109">N</span><span 
class="rm-lmr-10x-x-109">)</span>. Then, we want to compute the vector <span 
class="lmmi-10x-x-109">&#x03B1;</span><sup><span 
class="lmmi-8">&#x22C6;</span></sup> <span 
class="lmsy-10x-x-109">&#x2208; </span><span 
class="msbm-10x-x-109">&#x211D;</span><sup><span 
class="lmmi-8">N</span></sup> solving
</p>
<table 
class="equation-star"><tr><td>
<center class="math-display" >
<img 
src="pnl-manual22x.png" alt="             n ( N              )2
&#x03B1;&#x22C6; = argmin &#x2211;  ( &#x2211;  &#x03B1; f (x )- y )
         &#x03B1;  i=1  j=0  j j  i    i
" class="math-display"  /></center></td></tr></table>
<!--l. 57--><p class="nopar" >
</p>
<h4 class="subsectionHead"><span class="titlemark">7.2   </span> <a 
 id="x9-1040007.2"></a>Functions</h4>
     <ul class="itemize1">
     <li class="itemize"><a 
 id="dx9-104001"></a> <span class='ret'>int</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_basis_type_register</span></span>&#x00A0;(<span class='args'>const char *name, double (*f)(double, int), double
     (*Df)(double, int), double (*D2f)(double, int)</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Register a new basis type and return the index to be passed to <a 
href="#x9-1040007.2">pnl_basis_create</a> .
     The variable <span class='var'>name</span> is a unique string identifier of the family. The variables <span class='var'>f</span>, <span class='var'>Df</span>, <span class='var'>D2f</span> are the
     one dimensional basis functions, its first and second order derivatives. Each of these functions
     must return a <span class='var'>double</span> and take two arguments : the first one is the point at which evaluating
     the basis functions, the second one is the index of function. Here is a toy example to show
     how the canonical basis is registered (this family is actually already available with
     the id PNL_BASIS_CANONICAL, so the following example may look a little
     fake)
                                                                                    

                                                                                    
     <div class="verbatim" id="verbatim-38">
     &#x00A0;&#x00A0;double&#x00A0;f(double&#x00A0;x,&#x00A0;int&#x00A0;n)&#x00A0;{&#x00A0;return&#x00A0;pnl_pow_i(x,&#x00A0;n);&#x00A0;}
     &#x00A0;<br />&#x00A0;&#x00A0;double&#x00A0;Df(double&#x00A0;x,&#x00A0;int&#x00A0;n)&#x00A0;{&#x00A0;return&#x00A0;n&#x00A0;*&#x00A0;pnl_pow_i(x,&#x00A0;n-1);&#x00A0;}
     &#x00A0;<br />&#x00A0;&#x00A0;double&#x00A0;f(double&#x00A0;x,&#x00A0;int&#x00A0;n)&#x00A0;{&#x00A0;return&#x00A0;n&#x00A0;*&#x00A0;(n-1)&#x00A0;*&#x00A0;pnl_pow_i(x,&#x00A0;n-2);&#x00A0;}
     &#x00A0;<br />
     &#x00A0;<br />&#x00A0;&#x00A0;int&#x00A0;id&#x00A0;=&#x00A0;pnl_basis_register&#x00A0;("Canonic",&#x00A0;f,&#x00A0;Df,&#x00A0;D2f);
     &#x00A0;<br />&#x00A0;&#x00A0;/*
     &#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;*&#x00A0;B&#x00A0;is&#x00A0;the&#x00A0;Canonical&#x00A0;basis&#x00A0;of&#x00A0;polynomials&#x00A0;with&#x00A0;degree&#x00A0;less&#x00A0;or&#x00A0;equal&#x00A0;than&#x00A0;2&#x00A0;in
     &#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;*&#x00A0;dimension&#x00A0;5.
     &#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;*/
     &#x00A0;<br />&#x00A0;&#x00A0;PnlBasis&#x00A0;*B&#x00A0;=&#x00A0;pnl_basis_create_from_degree&#x00A0;(id,&#x00A0;2,&#x00A0;5);
     &#x00A0;<br />&#x00A0;&#x00A0;
</div>
     <!--l. 83--><p class="nopar" >
     </p></li>
     <li class="itemize"><a 
 id="dx9-104002"></a> <span class='ret'><a 
href="#x9-1030007.1"><span class='struct'>PnlBasis</span></a> *</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_basis_new</span></span>&#x00A0;(<span class='args'></span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Create an empty <a 
href="#x9-1030007.1"><span class='struct'>PnlBasis</span></a> .
     </li>
     <li class="itemize"><a 
 id="dx9-104003"></a> <span class='ret'>void</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_basis_print</span></span>&#x00A0;(<span class='args'>const <a 
href="#x9-1030007.1"><span class='struct'>PnlBasis</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>B</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Print the characteristics of a basis.
     </li>
     <li class="itemize"><a 
 id="dx9-104004"></a> <span class='ret'><a 
href="#x9-1030007.1"><span class='struct'>PnlBasis</span></a> *</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_basis_create</span></span>&#x00A0;(<span class='args'>int index, int nb_func, int nb_variates</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Create a <a 
href="#x9-1030007.1"><span class='struct'>PnlBasis</span></a> for the family defined by <span class='var'>index</span> (see Table&#x00A0;<a 
href="#x9-1030053">3<!--tex4ht:ref: basis_index --></a> and
     <a 
href="#x9-1040007.2">pnl_basis_type_register</a>) with <span class='var'>nb_variates</span> variates. The basis will contain <span class='var'>nb_func</span>.
     </li>
     <li class="itemize"><a 
 id="dx9-104005"></a> <span class='ret'><a 
href="#x9-1030007.1"><span class='struct'>PnlBasis</span></a> *</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_basis_create_from_degree</span></span>&#x00A0;(<span class='args'>int index, int degree, int nb_variates</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Create a <a 
href="#x9-1030007.1"><span class='struct'>PnlBasis</span></a> for the family defined by <span class='var'>index</span> (see Table&#x00A0;<a 
href="#x9-1030053">3<!--tex4ht:ref: basis_index --></a> and
     <a 
href="#x9-1040007.2">pnl_basis_type_register</a>) with total degree less or equal than <span class='var'>degree</span> and <span class='var'>nb_variates</span>
     variates. The total degree is the sum of the partial degrees.<br 
class="newline" />For instance, calling <span class="obeylines-h"><span class="verb"><span 
class="ec-lmtt-10x-x-109">pnl_basis_create_from_degree</span><span 
class="ec-lmtt-10x-x-109">&#x00A0;(index,</span><span 
class="ec-lmtt-10x-x-109">&#x00A0;2,</span><span 
class="ec-lmtt-10x-x-109">&#x00A0;4)</span></span></span> is equivalent to calling
     <span class="obeylines-h"><span class="verb"><span 
class="ec-lmtt-10x-x-109">pnl_basis_create_from_tensor</span><span 
class="ec-lmtt-10x-x-109">&#x00A0;(index,</span><span 
class="ec-lmtt-10x-x-109">&#x00A0;T)</span></span></span> where <span class='var'>T</span> is given by
     <center class="math-display" >
     <img 
src="pnl-manual23x.png" alt="(            )
  0  0  0  0
|| 1  0  0  0 ||
|| 0  1  0  0 ||
|| 0  0  1  0 ||
|| 0  0  0  1 ||
||            ||
|| 1  1  0  0 ||
|| 1  0  1  0 ||
|| 1  0  0  1 ||
|| 0  1  1  0 ||
|| 0  1  0  1 ||
|| 0  0  1  1 ||
|| 2  0  0  0 ||
|| 0  2  0  0 ||
||            ||
( 0  0  2  0 )
  0  0  0  2
     " class="math-display"  /></center>
     <!--l. 126--><p class="nopar" >
     </p></li>
     <li class="itemize"><a 
 id="dx9-104006"></a> <span class='ret'><a 
href="#x9-1030007.1"><span class='struct'>PnlBasis</span></a> *</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_basis_create_from_prod_degree</span></span>&#x00A0;(<span class='args'>int index, int degree, int
     nb_variates</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Create a <a 
href="#x9-1030007.1"><span class='struct'>PnlBasis</span></a> for the family defined by <span class='var'>index</span> (see Table&#x00A0;<a 
href="#x9-1030053">3<!--tex4ht:ref: basis_index --></a> and
     <a 
href="#x9-1040007.2">pnl_basis_type_register</a>) with total degree less or equal than <span class='var'>degree</span> and <span class='var'>nb_variates</span>
     variates. The total degree is the product of <span class='var'>MAX(1, d_i)</span> where the <span class='var'>d_i</span> are the partial
     degrees.
     </li>
     <li class="itemize"><a 
 id="dx9-104007"></a> <span class='ret'><a 
href="#x9-1030007.1"><span class='struct'>PnlBasis</span></a> *</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_basis_create_from_tensor</span></span>&#x00A0;(<span class='args'>int index, PnlMatInt <span 
class="ts1-lmr10-x-x-109">*</span>T</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Create a <a 
href="#x9-1030007.1"><span class='struct'>PnlBasis</span></a> for the polynomial family defined by <span class='var'>index</span> (see Table&#x00A0;<a 
href="#x9-1030053">3<!--tex4ht:ref: basis_index --></a>)
     using the basis described by the tensor matrix <span class='var'>T</span>. The number of lines of <span class='var'>T</span> is the number of
     functions of the basis whereas the numbers of columns of <span class='var'>T</span> is the number of variates of the
     functions. Note that <span class='var'>T</span> is not copied inside this function but only its address is stored, so
     <span 
class="ec-lmbx-10x-x-109">never </span>free <span class='var'>T</span>. It will be freed when calling <a 
href="#x9-1040007.2">pnl_basis_free</a> on the returned object.
     i<br 
class="newline" />Here is an example of a tensor matrix. Assume you are working with three variate functions,
     the basis <span class="obeylines-h"><span class="verb"><span 
class="ec-lmtt-10x-x-109">{</span><span 
class="ec-lmtt-10x-x-109">&#x00A0;1,</span><span 
class="ec-lmtt-10x-x-109">&#x00A0;x,</span><span 
class="ec-lmtt-10x-x-109">&#x00A0;y,</span><span 
class="ec-lmtt-10x-x-109">&#x00A0;z,</span><span 
class="ec-lmtt-10x-x-109">&#x00A0;x^2,</span><span 
class="ec-lmtt-10x-x-109">&#x00A0;xy,</span><span 
class="ec-lmtt-10x-x-109">&#x00A0;yz,</span><span 
class="ec-lmtt-10x-x-109">&#x00A0;z^3}</span></span></span> is decomposed in the one dimensional
     canonical basis using the following tensor matrix
     <center class="math-display" >
     <img 
src="pnl-manual24x.png" alt="(          )
   0  0  0
||  1  0  0 ||
||  0  1  0 ||
||  0  0  1 ||
||  2  0  0 ||
||          ||
||  1  1  0 ||
(  0  1  1 )
   0  0  3
     " class="math-display"  /></center>
     <!--l. 160--><p class="nopar" >
     </p></li>
     <li class="itemize"><a 
 id="dx9-104008"></a> <span class='ret'>void</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_basis_clone</span></span>&#x00A0;(<span class='args'><a 
href="#x9-1030007.1"><span class='struct'>PnlBasis</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>dest, const <a 
href="#x9-1030007.1"><span class='struct'>PnlBasis</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>src</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Clone <span class='var'>src</span> into <span class='var'>dest</span>. The basis <span class='var'>dest</span> must already exist before calling this
     function. On exit, <span class='var'>dest</span> and <span class='var'>src</span> are identical and independent.
     </li>
     <li class="itemize"><a 
 id="dx9-104009"></a> <span class='ret'><a 
href="#x9-1030007.1"><span class='struct'>PnlBasis</span></a> <span 
class="ts1-lmr10-x-x-109">*</span></span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_basis_copy</span></span>&#x00A0;(<span class='args'>const <a 
href="#x9-1030007.1"><span class='struct'>PnlBasis</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>B</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Create a copy of <span class='var'>B</span>.
     </li>
     <li class="itemize"><a 
 id="dx9-104010"></a> <span class='ret'>void </span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_basis_set_from_tensor</span></span>&#x00A0;(<span class='args'><a 
href="#x9-1030007.1"><span class='struct'>PnlBasis</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>b, int index, const <a 
href="pnl-manualse4.html#x6-430004.3.1"><span class='struct'>PnlMatInt</span></a>
     <span 
class="ts1-lmr10-x-x-109">*</span>T</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Set an alredy existing basis <span class='var'>b</span> to a polynomial family defined by <span class='var'>index</span> (see
     Table&#x00A0;<a 
href="#x9-1030053">3<!--tex4ht:ref: basis_index --></a>) using the basis described by the tensor matrix <span class='var'>T</span>. The number of lines of <span class='var'>T</span> is the
     number of functions of the basis whereas the numbers of columns of <span class='var'>T</span> is the number of
     variates of the functions. <br 
class="newline" />Same function as <a 
href="#x9-1040007.2">pnl_basis_create_from_tensor</a> except that it operates on an already
     existing basis.
     </li>
     <li class="itemize"><a 
 id="dx9-104011"></a> <span class='ret'><a 
href="#x9-1030007.1"><span class='struct'>PnlBasis</span></a> <span 
class="ts1-lmr10-x-x-109">*</span></span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_basis_create_from_hyperbolic_degree</span></span>&#x00A0;(<span class='args'>int index, double degree,
     double q, int n</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Create a sparse basis of polynomial with <span class='var'>n</span> variates. We give the example of the
     Canonical basis. A canonical polynomial with <span class='var'>n</span> variates writes <span 
class="lmmi-10x-x-109">X</span><sub><span 
class="rm-lmr-8">1</span></sub><sup><span 
class="lmmi-8">&#x03B1;</span><sub><span 
class="rm-lmr-6">1</span></sub></sup><span 
class="lmmi-10x-x-109">X</span><sub><span 
class="rm-lmr-8">2</span></sub><sup><span 
class="lmmi-8">&#x03B1;</span><sub><span 
class="rm-lmr-6">2</span></sub></sup><span 
class="lmmi-10x-x-109">&#x2026;</span><span 
class="lmmi-10x-x-109">X</span><sub><span 
class="lmmi-8">n</span></sub><sup><span 
class="lmmi-8">&#x03B1;</span><sub><span 
class="lmmi-6">n</span></sub></sup>. To be a
     member of the basis, it must satisfy <img 
src="pnl-manual25x.png" alt="(&#x2211;n   &#x03B1;iq)
   i=1"  class="left" align="middle" /><sup><span 
class="rm-lmr-8">1</span><span 
class="lmmi-8">&#x2215;q</span></sup> <span 
class="lmsy-10x-x-109">&#x2264; </span><span 
class="lmmi-10x-x-109">degree</span>. This kind of basis based on
     an hyperbolic set of indices gives priority to polynomials associated to low order
     interaction.
     </li>
     <li class="itemize"><a 
 id="dx9-104012"></a> <span class='ret'>void</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_basis_free</span></span>&#x00A0;(<span class='args'><a 
href="#x9-1030007.1"><span class='struct'>PnlBasis</span></a> <span 
class="ts1-lmr10-x-x-109">**</span>basis</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Free a <a 
href="#x9-1030007.1"><span class='struct'>PnlBasis</span></a> created by <a 
href="#x9-1040007.2">pnl_basis_create</a>. Beware that <span class='var'>basis</span> is the address
     of a <a 
href="#x9-1030007.1"><span class='struct'>PnlBasis</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>.
     </li>
     <li class="itemize"><a 
 id="dx9-104013"></a> <span class='ret'>void</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_basis_del_elt</span></span>&#x00A0;(<span class='args'><a 
href="#x9-1030007.1"><span class='struct'>PnlBasis</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>B, const <a 
href="pnl-manualse4.html#x6-250004.1.1"><span class='struct'>PnlVectInt</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>d</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Remove the function defined by the tensor product <span class='var'>d</span> from an existing basis
     <span class='var'>B</span>.
                                                                                    

                                                                                    
     </li>
     <li class="itemize"><a 
 id="dx9-104014"></a> <span class='ret'>void</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_basis_del_elt_i</span></span>&#x00A0;(<span class='args'><a 
href="#x9-1030007.1"><span class='struct'>PnlBasis</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>B, int i</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Remove the <span class='var'>i-th</span> element of basis <span class='var'>B</span>.
     </li>
     <li class="itemize"><a 
 id="dx9-104015"></a> <span class='ret'>void</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_basis_add_elt</span></span>&#x00A0;(<span class='args'><a 
href="#x9-1030007.1"><span class='struct'>PnlBasis</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>B, const <a 
href="pnl-manualse4.html#x6-250004.1.1"><span class='struct'>PnlVectInt</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>d</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Add the function defined by the tensor <span class='var'>d</span> to the Basis <span class='var'>B</span>.
     </li></ul>
<!--l. 208--><p class="noindent" >Functional regression based on a least square approach often leads to ill conditioned linear systems.
One way of improving the stability of the system is to use centered and renormalised
polynomials so that the original domain of interest <span 
class="lmsy-10x-x-109"><!--span 
class="htf-calligraphy"-->D<!--/span--> </span>(a subset of <span 
class="msbm-10x-x-109">&#x211D;</span><sup><span 
class="lmmi-8">d</span></sup>) is mapped to <span 
class="rm-lmr-10x-x-109">[</span><span 
class="lmsy-10x-x-109">-</span><span 
class="rm-lmr-10x-x-109">1</span><span 
class="lmmi-10x-x-109">,</span><span 
class="rm-lmr-10x-x-109">1]</span><sup><span 
class="lmmi-8">d</span></sup>.
If the domain <span 
class="lmsy-10x-x-109"><!--span 
class="htf-calligraphy"-->D<!--/span--> </span>is rectangular and writes <span 
class="rm-lmr-10x-x-109">[</span><span 
class="lmmi-10x-x-109">a,b</span><span 
class="rm-lmr-10x-x-109">] </span>where <span 
class="lmmi-10x-x-109">a,b </span><span 
class="lmsy-10x-x-109">&#x2208; </span><span 
class="msbm-10x-x-109">&#x211D;</span><sup><span 
class="lmmi-8">d</span></sup>, the mapping is done
by
</p>
<table 
class="equation"><tr><td><a 
 id="x9-104016r1"></a>
<center class="math-display" >
<img 
src="pnl-manual26x.png" alt="         ( x - (b + a )&#x2215;2)
x &#x2208; D &#x21A6;-&#x2192;   -i----i---i---
             (bi - ai)&#x2215;2   i=1,&#x22C5;&#x22C5;&#x22C5;,d
" class="math-display"  /></center></td><td class="equation-label">(1)</td></tr></table>
<!--l. 217--><p class="nopar" >
</p>
     <ul class="itemize1">
     <li class="itemize"><a 
 id="dx9-104017"></a> <span class='ret'>void</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_basis_set_domain</span></span>&#x00A0;(<span class='args'><a 
href="#x9-1030007.1"><span class='struct'>PnlBasis</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>B, const <a 
href="pnl-manualse4.html#x6-250004.1.1"><span class='struct'>PnlVect</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>a, const <a 
href="pnl-manualse4.html#x6-250004.1.1"><span class='struct'>PnlVect</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>b</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>This function declares <span class='var'>B</span> as a centered and normalised basis as defined by
     Equation&#x00A0;<a 
href="#x9-104016r1">1<!--tex4ht:ref: basis_reduced --></a>. Calling this function is equivalent to calling <a 
href="#x9-1040007.2">pnl_basis_set_reduced</a> with
     <span class='var'>center=(b+a)/2</span> and <span class='var'>scale=(b-a)/2</span>.
     </li>
     <li class="itemize"><a 
 id="dx9-104018"></a> <span class='ret'>void</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_basis_set_reduced</span></span>&#x00A0;(<span class='args'><a 
href="#x9-1030007.1"><span class='struct'>PnlBasis</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>B, const <a 
href="pnl-manualse4.html#x6-250004.1.1"><span class='struct'>PnlVect</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>center, const <a 
href="pnl-manualse4.html#x6-250004.1.1"><span class='struct'>PnlVect</span></a>
     <span 
class="ts1-lmr10-x-x-109">*</span>scale</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>This function declares <span class='var'>B</span> as a centered and normalised basis using the
     mapping
     <table 
class="equation-star"><tr><td>
                                                                                    

                                                                                    
     <center class="math-display" >
     <img 
src="pnl-manual27x.png" alt="          (            )
            xi --centeri
x &#x2208; D &#x21A6;- &#x2192;      scalei    i=1,&#x22C5;&#x22C5;&#x22C5;,d
     " class="math-display"  /></center></td></tr></table>
     <!--l. 232--><p class="nopar" >
     </p></li></ul>
     <ul class="itemize1">
     <li class="itemize"><a 
 id="dx9-104019"></a> <span class='ret'>int</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_basis_fit_ls</span></span>&#x00A0;(<span class='args'><a 
href="#x9-1030007.1"><span class='struct'>PnlBasis</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>P, <a 
href="pnl-manualse4.html#x6-250004.1.1"><span class='struct'>PnlVect</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>coef, <a 
href="pnl-manualse4.html#x6-430004.3.1"><span class='struct'>PnlMat</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>x, <a 
href="pnl-manualse4.html#x6-250004.1.1"><span class='struct'>PnlVect</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>y</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Compute the coefficients <span class='var'>coef</span> defined by
     <table 
class="equation-star"><tr><td>
     <center class="math-display" >
     <img 
src="pnl-manual28x.png" alt="               n ( N              ) 2
coef = argmin &#x2211;  ( &#x2211;  &#x03B1; P (x )- y )
           &#x03B1;           j j  i    i
              i=1  j=0
     " class="math-display"  /></center></td></tr></table>
     <!--l. 244--><p class="nopar" >
     where <span class='var'>N</span> is the number of functions to regress upon and <span 
class="lmmi-10x-x-109">n </span>is the number of points at which the
     values of the original function are known. <span 
class="lmmi-10x-x-109">P</span><sub><span 
class="lmmi-8">j</span></sub> is the <span 
class="lmmi-10x-x-109">j </span><span 
class="lmsy-10x-x-109">- </span><span 
class="lmmi-10x-x-109">th </span>basis function. Each
     row of the matrix <span class='var'>x</span> defines the coordinates of one point <span 
class="lmmi-10x-x-109">x</span><sub><span 
class="lmmi-8">i</span></sub>. The function to be
     approximated is defined by the vector <span class='var'>y</span> of the values of the function at the points
     <span class='var'>x</span>.
     </p></li>
     <li class="itemize"><a 
 id="dx9-104020"></a> <span class='ret'>double</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_basis_ik_vect</span></span>&#x00A0;(<span class='args'>const <a 
href="#x9-1030007.1"><span class='struct'>PnlBasis</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>b, const <a 
href="pnl-manualse4.html#x6-250004.1.1"><span class='struct'>PnlVect</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>x, int i, int
     k</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>An element of a basis writes <span 
class="lmex-10">&#x220F;</span>
  <sub><span 
class="lmmi-8">l</span><span 
class="rm-lmr-8">=0</span></sub><sup><span class='var'><span 
class="lmmi-8">nb</span><sub><span 
class="lmmi-6">v</span></sub><span 
class="lmmi-8">ariates</span></span></sup><span 
class="lmmi-10x-x-109">&#x03D5;</span><sub><span 
class="lmmi-8">l</span></sub><span 
class="rm-lmr-10x-x-109">(</span><span 
class="lmmi-10x-x-109">x</span><sub><span 
class="lmmi-8">l</span></sub><span 
class="rm-lmr-10x-x-109">) </span>where the <span 
class="lmmi-10x-x-109">&#x03D5;</span>&#8217;s are one
     dimensional polynomials. This functions computes the therm <span 
class="lmmi-10x-x-109">&#x03D5;</span><sub><span 
class="lmmi-8">k</span></sub> of the <span class='var'>i-th</span> basis function at
     the point <span class='var'>x</span>.
     </li>
     <li class="itemize"><a 
 id="dx9-104021"></a> <span class='ret'>double</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_basis_i_vect</span></span>&#x00A0;(<span class='args'>const <a 
href="#x9-1030007.1"><span class='struct'>PnlBasis</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>b, const <a 
href="pnl-manualse4.html#x6-250004.1.1"><span class='struct'>PnlVect</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>x, int i</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>If <span class='var'>b</span> is composed of <span 
class="lmmi-10x-x-109">f</span><sub><span 
class="rm-lmr-8">0</span></sub><span 
class="lmmi-10x-x-109">,</span><span 
class="lmmi-10x-x-109">&#x2026;</span><span 
class="lmmi-10x-x-109">,f</span><sub><span class='var'><span 
class="lmmi-8">nb</span>_<span 
class="lmmi-8">func</span></span><span 
class="lmsy8-">-</span><span 
class="rm-lmr-8">1</span></sub>, then this function returns
     <span 
class="lmmi-10x-x-109">f</span><sub><span 
class="lmmi-8">i</span></sub><span 
class="rm-lmr-10x-x-109">(</span><span 
class="lmmi-10x-x-109">x</span><span 
class="rm-lmr-10x-x-109">)</span>.
                                                                                    

                                                                                    
     </li>
     <li class="itemize"><a 
 id="dx9-104022"></a> <span class='ret'>double</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_basis_i_D_vect</span></span>&#x00A0;(<span class='args'>const <a 
href="#x9-1030007.1"><span class='struct'>PnlBasis</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>b, const <a 
href="pnl-manualse4.html#x6-250004.1.1"><span class='struct'>PnlVect</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>x, int i, int
     j</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>If <span class='var'>b</span> is composed of <span 
class="lmmi-10x-x-109">f</span><sub><span 
class="rm-lmr-8">0</span></sub><span 
class="lmmi-10x-x-109">,</span><span 
class="lmmi-10x-x-109">&#x2026;</span><span 
class="lmmi-10x-x-109">,f</span><sub><span class='var'><span 
class="lmmi-8">nb</span>_<span 
class="lmmi-8">func</span></span><span 
class="lmsy8-">-</span><span 
class="rm-lmr-8">1</span></sub>, then this function returns
     <span 
class="lmmi-10x-x-109">&#x2202;</span><sub><span 
class="lmmi-8">x</span><sub><span class='var'><span 
class="lmmi-6">j</span></span></sub></sub><span 
class="lmmi-10x-x-109">f</span><sub><span 
class="lmmi-8">i</span></sub><span 
class="rm-lmr-10x-x-109">(</span><span 
class="lmmi-10x-x-109">x</span><span 
class="rm-lmr-10x-x-109">)</span>.
     </li>
     <li class="itemize"><a 
 id="dx9-104023"></a> <span class='ret'>double</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_basis_i_D2_vect</span></span>&#x00A0;(<span class='args'>const <a 
href="#x9-1030007.1"><span class='struct'>PnlBasis</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>b, const <a 
href="pnl-manualse4.html#x6-250004.1.1"><span class='struct'>PnlVect</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>x, int i, int j1, int
     j2</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>If <span class='var'>b</span> is composed of <span 
class="lmmi-10x-x-109">f</span><sub><span 
class="rm-lmr-8">0</span></sub><span 
class="lmmi-10x-x-109">,</span><span 
class="lmmi-10x-x-109">&#x2026;</span><span 
class="lmmi-10x-x-109">,f</span><sub><span class='var'><span 
class="lmmi-8">nb</span>_<span 
class="lmmi-8">func</span></span><span 
class="lmsy8-">-</span><span 
class="rm-lmr-8">1</span></sub>, then this function returns
     <span 
class="lmmi-10x-x-109">&#x2202;</span><sup><span 
class="rm-lmr-8">2</span></sup><sub><span 
class="lmmi-8">x</span><sub><span class='var'><span 
class="lmmi-6">j</span><span 
class="rm-lmr-6">1</span></span></sub><span 
class="lmmi-8">,x</span><sub><span class='var'><span 
class="lmmi-6">j</span><span 
class="rm-lmr-6">2</span></span></sub></sub><span 
class="lmmi-10x-x-109">f</span><sub><span 
class="lmmi-8">i</span></sub><span 
class="rm-lmr-10x-x-109">(</span><span 
class="lmmi-10x-x-109">x</span><span 
class="rm-lmr-10x-x-109">)</span>.
     </li>
     <li class="itemize"><a 
 id="dx9-104024"></a> <span class='ret'>void</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_basis_eval_derivs_vect</span></span>&#x00A0;(<span class='args'>const <a 
href="#x9-1030007.1"><span class='struct'>PnlBasis</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>b, const <a 
href="pnl-manualse4.html#x6-250004.1.1"><span class='struct'>PnlVect</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>coef, const
     <a 
href="pnl-manualse4.html#x6-250004.1.1"><span class='struct'>PnlVect</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>x, double <span 
class="ts1-lmr10-x-x-109">*</span>fx, <a 
href="pnl-manualse4.html#x6-250004.1.1"><span class='struct'>PnlVect</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>Dfx, <a 
href="pnl-manualse4.html#x6-430004.3.1"><span class='struct'>PnlMat</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>D2fx</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Compute the function, the gradient and the Hessian matrix of
     <span 
class="lmex-10">&#x2211;</span>
       <sub><span 
class="lmmi-8">k</span><span 
class="rm-lmr-8">=0</span></sub><sup><span 
class="lmmi-8">n</span></sup><span class='var'><span 
class="lmmi-10x-x-109">coef</span></span><sub><span 
class="lmmi-8">k</span></sub><span 
class="lmmi-10x-x-109">P</span><sub><span 
class="lmmi-8">k</span></sub><span 
class="rm-lmr-10x-x-109">(</span><span 
class="lmsy-10x-x-109">&#x22C5;</span><span 
class="rm-lmr-10x-x-109">) </span>at the point <span class='var'>x</span>. On output, <span class='var'>fx</span> contains the value of the function, <span class='var'>Dfx</span> its
     gradient and <span class='var'>D2fx</span> its Hessian matrix. This function is optimized and performs much
     better than calling <a 
href="#x9-1040007.2">pnl_basis_eval</a>, <a 
href="#x9-1040007.2">pnl_basis_eval_D</a> and <a 
href="#x9-1040007.2">pnl_basis_eval_D2</a>
     sequentially.
     </li>
     <li class="itemize"><a 
 id="dx9-104025"></a> <span class='ret'>double</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_basis_eval_vect</span></span>&#x00A0;(<span class='args'>const <a 
href="#x9-1030007.1"><span class='struct'>PnlBasis</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>basis, const <a 
href="pnl-manualse4.html#x6-250004.1.1"><span class='struct'>PnlVect</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>coef, const <a 
href="pnl-manualse4.html#x6-250004.1.1"><span class='struct'>PnlVect</span></a>
     <span 
class="ts1-lmr10-x-x-109">*</span>x</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Compute the linear combination of <span class='var'>P_k(x)</span> defined by <span class='var'>coef</span>. Given
     the coefficients computed by the function <a 
href="#x9-1040007.2">pnl_basis_fit_ls</a>, this function returns
     <span 
class="lmex-10">&#x2211;</span>
       <sub><span 
class="lmmi-8">k</span><span 
class="rm-lmr-8">=0</span></sub><sup><span 
class="lmmi-8">n</span></sup><span class='var'><span 
class="lmmi-10x-x-109">coef</span></span><sub><span 
class="lmmi-8">k</span></sub><span 
class="lmmi-10x-x-109">P</span><sub><span 
class="lmmi-8">k</span></sub><span 
class="rm-lmr-10x-x-109">(</span><span class='var'><span 
class="lmmi-10x-x-109">x</span></span><span 
class="rm-lmr-10x-x-109">)</span>.
     </li>
     <li class="itemize"><a 
 id="dx9-104026"></a> <span class='ret'>double</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_basis_eval_D_vect</span></span>&#x00A0;(<span class='args'>const <a 
href="#x9-1030007.1"><span class='struct'>PnlBasis</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>basis, const <a 
href="pnl-manualse4.html#x6-250004.1.1"><span class='struct'>PnlVect</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>coef, const
     <a 
href="pnl-manualse4.html#x6-250004.1.1"><span class='struct'>PnlVect</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>x, int i</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Compute the derivative with respect to <span class='var'>x_i</span> of the linear combination of
     <span class='var'>P_k(x)</span> defined by <span class='var'>coef</span>. Given the coefficients computed by the function <a 
href="#x9-1040007.2">pnl_basis_fit_ls</a>,
     this function returns <span 
class="lmmi-10x-x-109">&#x2202;</span><sub><span 
class="lmmi-8">x</span><sub><span 
class="lmmi-6">i</span></sub></sub> <span 
class="lmex-10">&#x2211;</span>
   <sub><span 
class="lmmi-8">k</span><span 
class="rm-lmr-8">=0</span></sub><sup><span 
class="lmmi-8">n</span></sup><span class='var'><span 
class="lmmi-10x-x-109">coef</span></span><sub><span 
class="lmmi-8">k</span></sub><span 
class="lmmi-10x-x-109">P</span><sub><span 
class="lmmi-8">k</span></sub><span 
class="rm-lmr-10x-x-109">(</span><span class='var'><span 
class="lmmi-10x-x-109">x</span></span><span 
class="rm-lmr-10x-x-109">) </span>The index <span class='var'>i</span> may vary between <span class='var'>0</span> and
     <span class='var'>P-&#x003E;nb_variates - 1</span>.
     </li>
     <li class="itemize"><a 
 id="dx9-104027"></a> <span class='ret'>double</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_basis_eval_D2_vect</span></span>&#x00A0;(<span class='args'>const <a 
href="#x9-1030007.1"><span class='struct'>PnlBasis</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>basis, const <a 
href="pnl-manualse4.html#x6-250004.1.1"><span class='struct'>PnlVect</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>coef, const
     <a 
href="pnl-manualse4.html#x6-250004.1.1"><span class='struct'>PnlVect</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>x, int i, int j</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Compute the derivative with respect to <span class='var'>x_i</span> of the linear combination of
     <span class='var'>P_k(x)</span> defined by <span class='var'>coef</span>. Given the coefficients computed by the function <a 
href="#x9-1040007.2">pnl_basis_fit_ls</a>,
     this function returns <span 
class="lmmi-10x-x-109">&#x2202;</span><sub><span 
class="lmmi-8">x</span><sub><span 
class="lmmi-6">i</span></sub></sub><span 
class="lmmi-10x-x-109">&#x2202;</span><sub><span 
class="lmmi-8">x</span><sub><span 
class="lmmi-6">j</span></sub></sub> <span 
class="lmex-10">&#x2211;</span>
   <sub><span 
class="lmmi-8">k</span><span 
class="rm-lmr-8">=0</span></sub><sup><span 
class="lmmi-8">n</span></sup><span class='var'><span 
class="lmmi-10x-x-109">coef</span></span><sub><span 
class="lmmi-8">k</span></sub><span 
class="lmmi-10x-x-109">P</span><sub><span 
class="lmmi-8">k</span></sub><span 
class="rm-lmr-10x-x-109">(</span><span class='var'><span 
class="lmmi-10x-x-109">x</span></span><span 
class="rm-lmr-10x-x-109">)</span>. The indices <span class='var'>i</span> and <span class='var'>j</span> may vary between <span class='var'>0</span> and
     <span class='var'>P-&#x003E;nb_variates - 1</span>.
     </li>
     <li class="itemize"><a 
 id="dx9-104028"></a> <span class='ret'>double</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_basis_ik</span></span>&#x00A0;(<span class='args'>const <a 
href="#x9-1030007.1"><span class='struct'>PnlBasis</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>b, const double <span 
class="ts1-lmr10-x-x-109">*</span>x, int i, int k</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Same as function <a 
href="#x9-1040007.2">pnl_basis_ik_vect</a> but takes a C array as the point of
     evaluation.
                                                                                    

                                                                                    
     </li>
     <li class="itemize"><a 
 id="dx9-104029"></a> <span class='ret'>double</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_basis_i</span></span>&#x00A0;(<span class='args'><a 
href="#x9-1030007.1"><span class='struct'>PnlBasis</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>b, double <span 
class="ts1-lmr10-x-x-109">*</span>x, int i</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Same as function <a 
href="#x9-1040007.2">pnl_basis_i_vect</a> but takes a C array as the point of
     evaluation.
     </li>
     <li class="itemize"><a 
 id="dx9-104030"></a> <span class='ret'>double</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_basis_i_D</span></span>&#x00A0;(<span class='args'> const <a 
href="#x9-1030007.1"><span class='struct'>PnlBasis</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>b, const double <span 
class="ts1-lmr10-x-x-109">*</span>x, int i, int j </span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Same as function <a 
href="#x9-1040007.2">pnl_basis_i_D_vect</a> but takes a C array as the point of
     evaluation.
     </li>
     <li class="itemize"><a 
 id="dx9-104031"></a> <span class='ret'>double</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_basis_i_D2</span></span>&#x00A0;(<span class='args'>const <a 
href="#x9-1030007.1"><span class='struct'>PnlBasis</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>b, const double <span 
class="ts1-lmr10-x-x-109">*</span>x, int i, int j1, int
     j2</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Same as function <a 
href="#x9-1040007.2">pnl_basis_i_D2_vect</a> but takes a C array as the point of
     evaluation.
     </li>
     <li class="itemize"><a 
 id="dx9-104032"></a> <span class='ret'>double</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_basis_eval</span></span>&#x00A0;(<span class='args'><a 
href="#x9-1030007.1"><span class='struct'>PnlBasis</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>P, <a 
href="pnl-manualse4.html#x6-250004.1.1"><span class='struct'>PnlVect</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>coef, double <span 
class="ts1-lmr10-x-x-109">*</span>x</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Same as function <a 
href="#x9-1040007.2">pnl_basis_eval_vect</a> but takes a C array as the point of
     evaluation.
     </li>
     <li class="itemize"><a 
 id="dx9-104033"></a> <span class='ret'>double</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_basis_eval_D</span></span>&#x00A0;(<span class='args'><a 
href="#x9-1030007.1"><span class='struct'>PnlBasis</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>P, <a 
href="pnl-manualse4.html#x6-250004.1.1"><span class='struct'>PnlVect</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>coef, double <span 
class="ts1-lmr10-x-x-109">*</span>x, int i</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Same as function <a 
href="#x9-1040007.2">pnl_basis_eval_D_vect</a> but takes a C array as the point of
     evaluation.
     </li>
     <li class="itemize"><a 
 id="dx9-104034"></a> <span class='ret'>double</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_basis_eval_D2</span></span>&#x00A0;(<span class='args'><a 
href="#x9-1030007.1"><span class='struct'>PnlBasis</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>P, <a 
href="pnl-manualse4.html#x6-250004.1.1"><span class='struct'>PnlVect</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>coef, double <span 
class="ts1-lmr10-x-x-109">*</span>x, int i, int
     j</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Same as function <a 
href="#x9-1040007.2">pnl_basis_eval_D2_vect</a> but takes a C array as the point of
     evaluation.
     </li>
     <li class="itemize"><a 
 id="dx9-104035"></a> <span class='ret'>double</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_basis_eval_derivs</span></span>&#x00A0;(<span class='args'><a 
href="#x9-1030007.1"><span class='struct'>PnlBasis</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>P, <a 
href="pnl-manualse4.html#x6-250004.1.1"><span class='struct'>PnlVect</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>coef, double <span 
class="ts1-lmr10-x-x-109">*</span>x, double <span 
class="ts1-lmr10-x-x-109">*</span>fx,
     <a 
href="pnl-manualse4.html#x6-250004.1.1"><span class='struct'>PnlVect</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>Dfx, <a 
href="pnl-manualse4.html#x6-430004.3.1"><span class='struct'>PnlMat</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>D2fx</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Same as function <a 
href="#x9-1040007.2">pnl_basis_eval_derivs_vect</a> but takes a C array as the point
     of evaluation.</li></ul>
                                                                                    

                                                                                    
<!--l. 1--><div class="crosslinks"><p class="noindent">[<a 
href="pnl-manualse8.html" >next</a>] [<a 
href="pnl-manualse6.html" >prev</a>] [<a 
href="pnl-manualse6.html#tailpnl-manualse6.html" >prev-tail</a>] [<a 
href="pnl-manualse7.html" >front</a>] [<a 
href="pnl-manual.html#pnl-manualse7.html" >up</a>] </p></div>
<!--l. 1--><p class="noindent" ><a 
 id="tailpnl-manualse7.html"></a> </p> 
</body></html> 
