<?xml version="1.0" encoding="iso-8859-1" ?> 
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" 
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">  
<!--http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd-->  
<html xmlns="http://www.w3.org/1999/xhtml"  
> 
<head><title>Nonlinear Constrained Optimization</title> 
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1" /> 
<meta name="generator" content="TeX4ht (http://www.tug.org/tex4ht/)" /> 
<meta name="originator" content="TeX4ht (http://www.tug.org/tex4ht/)" /> 
<!-- xhtml,uni-html4,2,subsection+,next,html --> 
<meta name="src" content="pnl-manual.tex" /> 
<meta name="date" content="2014-07-22 17:33:00" /> 
<link rel="stylesheet" type="text/css" href="pnl-manual.css" /> 
</head><body 
>
<!--l. 1--><div class="crosslinks"><p class="noindent">[<a 
href="pnl-manualse13.html" >next</a>] [<a 
href="pnl-manualse11.html" >prev</a>] [<a 
href="pnl-manualse11.html#tailpnl-manualse11.html" >prev-tail</a>] [<a 
href="#tailpnl-manualse12.html">tail</a>] [<a 
href="pnl-manual.html#pnl-manualse12.html" >up</a>] </p></div>
<h3 class="sectionHead"><span class="titlemark">12   </span> <a 
 id="x14-11600012"></a>Nonlinear Constrained Optimization</h3>
<!--l. 2--><p class="noindent" >
</p>
<h4 class="subsectionHead"><span class="titlemark">12.1   </span> <a 
 id="x14-11700012.1"></a>Overview</h4>
<!--l. 4--><p class="noindent" >A standard Constrained Nonlinear Optimization problem can be written as:
</p>
<table 
class="equation-star"><tr><td>
<center class="math-display" >
<img 
src="pnl-manual36x.png" alt="   (|  min f(x)
(O ){  cI(x) &#x2265; 0
   |(   E
      c (x) = 0
" class="math-display"  /></center></td></tr></table>
<!--l. 15--><p class="nopar" >
</p><!--l. 17--><p class="noindent" >where the function <span 
class="lmmi-10x-x-109">f </span><span 
class="rm-lmr-10x-x-109">: </span><span 
class="msbm-10x-x-109">&#x211D;</span><sup><span 
class="lmmi-8">n</span></sup> <span 
class="lmsy-10x-x-109">&#x2192; </span><span 
class="msbm-10x-x-109">&#x211D; </span>is the objective function, <span 
class="lmmi-10x-x-109">c</span><sup><span 
class="lmmi-8">I</span></sup> <span 
class="rm-lmr-10x-x-109">: </span><span 
class="msbm-10x-x-109">&#x211D;</span><sup><span 
class="lmmi-8">n</span></sup> <span 
class="lmsy-10x-x-109">&#x2192; </span><span 
class="msbm-10x-x-109">&#x211D;</span><sup><span 
class="lmmi-8">m</span><sub><span 
class="lmmi-6">I</span></sub></sup> are the inequality
constraints and <span 
class="lmmi-10x-x-109">c</span><sup><span 
class="lmmi-8">E</span></sup> <span 
class="rm-lmr-10x-x-109">: </span><span 
class="msbm-10x-x-109">&#x211D;</span><sup><span 
class="lmmi-8">n</span></sup> <span 
class="lmsy-10x-x-109">&#x2192; </span><span 
class="msbm-10x-x-109">&#x211D;</span><sup><span 
class="lmmi-8">m</span><sub><span 
class="lmmi-6">E</span></sub></sup> are the equality constraints. These functions are supposed to be
smooth.
</p><!--l. 19--><p class="noindent" >In general, the inequality constraints are of the form <span 
class="lmmi-10x-x-109">c</span><sup><span 
class="lmmi-8">I</span></sup><span 
class="rm-lmr-10x-x-109">(</span><span 
class="lmmi-10x-x-109">x</span><span 
class="rm-lmr-10x-x-109">) = </span><img 
src="pnl-manual37x.png" alt="(g(x),x - l,u - x)"  class="left" align="middle" />. The vector <span 
class="lmmi-10x-x-109">l </span>and <span 
class="lmmi-10x-x-109">u</span>
are the lower and upper bounds on the variables <span 
class="lmmi-10x-x-109">x </span>and <span 
class="lmmi-10x-x-109">g</span><span 
class="rm-lmr-10x-x-109">(</span><span 
class="lmmi-10x-x-109">x</span><span 
class="rm-lmr-10x-x-109">) </span>and the non linear inequality
constraints.
</p><!--l. 21--><p class="noindent" >Under some conditions, if <span 
class="lmmi-10x-x-109">x </span><span 
class="lmsy-10x-x-109">&#x2208; </span><span 
class="msbm-10x-x-109">&#x211D;</span><sup><span 
class="lmmi-8">n</span></sup> is a solution of problem (<span 
class="lmmi-10x-x-109">O</span>), then there exist a vector
<span 
class="lmmi-10x-x-109">&#x03BB; </span><span 
class="rm-lmr-10x-x-109">= (</span><span 
class="lmmi-10x-x-109">&#x03BB;</span><sup><span 
class="lmmi-8">I</span></sup><span 
class="lmmi-10x-x-109">,&#x03BB;</span><sup><span 
class="lmmi-8">E</span></sup><span 
class="rm-lmr-10x-x-109">) </span><span 
class="lmsy-10x-x-109">&#x2208; </span><span 
class="msbm-10x-x-109">&#x211D;</span><sup><span 
class="lmmi-8">m</span><sub><span 
class="lmmi-6">I</span></sub></sup> <span 
class="lmsy-10x-x-109">&#x00D7; </span><span 
class="msbm-10x-x-109">&#x211D;</span><sup><span 
class="lmmi-8">m</span><sub><span 
class="lmmi-6">E</span></sub></sup>, such that the well known Karush-Kuhn-Tucker (KKT) optimality
conditions are satisfied:
</p>
<table 
class="equation-star"><tr><td>
                                                                                    

                                                                                    
<center class="math-display" >
<img 
src="pnl-manual38x.png" alt="    (
    ||  &#x2207; &#x2113;(x,&#x03BB;I,&#x03BB;E ) = &#x2207;f (x )- &#x2207;cI(x)&#x03BB;I - &#x2207;cE (x)&#x03BB;E = 0
    |||{                     cE(x) = 0
(P )                      cI(x) &#x2265; 0
    |||                        I
    ||(                I    I &#x03BB; &#x2265; 0
                    ci(x)&#x03BB;i = 0,i = 1...mI
" class="math-display"  /></center></td></tr></table>
<!--l. 34--><p class="nopar" >
</p><!--l. 36--><p class="noindent" ><span 
class="lmmi-10x-x-109">l </span>is known as the lagrangian of the problem <span 
class="rm-lmr-10x-x-109">(</span><span 
class="lmmi-10x-x-109">O</span><span 
class="rm-lmr-10x-x-109">)</span>, <span 
class="lmmi-10x-x-109">&#x03BB;</span><sup><span 
class="lmmi-8">I</span></sup> and <span 
class="lmmi-10x-x-109">&#x03BB;</span><sup><span 
class="lmmi-8">E</span></sup> as the dual variables while <span 
class="lmmi-10x-x-109">x </span>is the
primal variable.
</p><!--l. 38--><p class="noindent" >
</p>
<h4 class="subsectionHead"><span class="titlemark">12.2   </span> <a 
 id="x14-11800012.2"></a>Functions</h4>
<!--l. 40--><p class="noindent" >To use the following functions, you should include <span class="obeylines-h"><span class="verb"><span 
class="ec-lmtt-10x-x-109">pnl/pnl_optim.h</span></span></span>.
</p><!--l. 42--><p class="noindent" >To solve an inequality constrained optimization problem, ie <span 
class="lmmi-10x-x-109">m</span><sub><span 
class="lmmi-8">E</span></sub> <span 
class="rm-lmr-10x-x-109">= 0</span>, we provide the following
function. </p>
     <ul class="itemize1">
     <li class="itemize"><a 
 id="dx14-118001"></a>                              <span class='ret'>int</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_optim_intpoints_bfgs_solve</span></span>&#x00A0;(<span class='args'><a 
href="pnl-manualse13.html#x15-12000013.1"><span class='struct'>PnlRnFuncR</span></a><span 
class="ts1-lmr10-x-x-109">*</span>func,
     <a 
href="pnl-manualse13.html#x15-12000013.1"><span class='struct'>PnlRnFuncRm</span></a><span 
class="ts1-lmr10-x-x-109">*</span>grad_func,  <a 
href="pnl-manualse13.html#x15-12000013.1"><span class='struct'>PnlRnFuncRm</span></a><span 
class="ts1-lmr10-x-x-109">*</span>nl_constraints,  <a 
href="pnl-manualse4.html#x6-250004.1.1"><span class='struct'>PnlVect</span></a>  <span 
class="ts1-lmr10-x-x-109">*</span>lower_bounds,
     <a 
href="pnl-manualse4.html#x6-250004.1.1"><span class='struct'>PnlVect</span></a>  <span 
class="ts1-lmr10-x-x-109">*</span>upper_bounds,  <a 
href="pnl-manualse4.html#x6-250004.1.1"><span class='struct'>PnlVect</span></a>  <span 
class="ts1-lmr10-x-x-109">*</span>x_input,  double  tolerance,  int  iter_max,  int
     print_inner_steps, <a 
href="pnl-manualse4.html#x6-250004.1.1"><span class='struct'>PnlVect</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>output</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>This function has the following arguments:
          <ul class="itemize2">
          <li class="itemize"><span class='var'>func</span> is the function to minimize <span 
class="lmmi-10x-x-109">f</span>.
          </li>
          <li class="itemize"><span class='var'>grad</span> is the gradient of <span 
class="lmmi-10x-x-109">f</span>. If this gradient is not available, then enter <span class='var'>grad</span>=NULL.
          In this case, finite difference will be used to estimate the gradient.
          </li>
          <li class="itemize"><span class='var'>nl_constraints</span> is the function <span 
class="lmmi-10x-x-109">g</span><span 
class="rm-lmr-10x-x-109">(</span><span 
class="lmmi-10x-x-109">x</span><span 
class="rm-lmr-10x-x-109">)</span>, ie the non linear inequality constraints.
          </li>
          <li class="itemize"><span class='var'>lower_bounds</span> are the lower bounds on <span 
class="lmmi-10x-x-109">x</span>. Can be NULL if there is no lower bound.
          </li>
          <li class="itemize"><span class='var'>upper_bounds</span> are the upper bounds on <span 
class="lmmi-10x-x-109">x</span>. Can be NULL if there is no upper
          bound.
                                                                                    

                                                                                    
          </li>
          <li class="itemize"><span class='var'>x_input</span> is the initial point where the algorithm starts.
          </li>
          <li class="itemize"><span class='var'>tolerance</span> is the precision required in solving (P).
          </li>
          <li class="itemize"><span class='var'>iter_max</span> is the maximum number of iterations in the algorithm.
          </li>
          <li class="itemize"><span class='var'>print_algo_steps</span> is a flag to decide to print information.
          </li>
          <li class="itemize"><span class='var'>x_output</span> is the point where the algorithm stops.</li></ul>
     <!--l. 62--><p class="noindent" >The algorithm returns an <span 
class="lmmi-10x-x-109">int</span>, its value depends on the output status of the algorithm. We
     have 4 cases: </p>
          <ul class="itemize2">
          <li class="itemize">0: Failure: Initial point is not strictly feasible.
          </li>
          <li class="itemize">1: Step is too small, we stop the algorithm.
          </li>
          <li class="itemize">2: Maximum number of iterations reached.
          </li>
          <li class="itemize">3: A solution has been found up to the required accuracy.</li></ul>
     <!--l. 70--><p class="noindent" >The last case is equivalent to the two inequalities:
     </p><!--l. 72--><p class="noindent" >
     </p>
     <center class="math-display" >
     <img 
src="pnl-manual39x.png" alt="||&#x2207;&#x2113;(x,&#x03BB;I)||  = ||&#x2207;f (x)- &#x2207;cI (x)&#x03BB;I||  &#x003C; tolerance
           &#x221E;                       &#x221E;
     " class="math-display"  /></center>
     <center class="math-display" >
     <img 
src="pnl-manual40x.png" alt="||cI(x)&#x03BB;I||&#x221E; &#x003C;  tolerance
     " class="math-display"  /></center>
                                                                                    

                                                                                    
     <!--l. 75--><p class="noindent" >where <span 
class="lmmi-10x-x-109">c</span><sup><span 
class="lmmi-8">I</span></sup><span 
class="rm-lmr-10x-x-109">(</span><span 
class="lmmi-10x-x-109">x</span><span 
class="rm-lmr-10x-x-109">)</span><span style="margin-left:2.43306pt" class="tmspace"></span><span 
class="lmmi-10x-x-109">. </span><span 
class="lmsy-10x-x-109">*</span><span style="margin-left:2.43306pt" class="tmspace"></span><span 
class="lmmi-10x-x-109">&#x03BB;</span><sup><span 
class="lmmi-8">I</span></sup> where &#8217;<span 
class="lmmi-10x-x-109">.</span><span 
class="lmsy-10x-x-109">*</span>&#8217; denotes the term by term multiplication.
     </p><!--l. 77--><p class="noindent" >The first inequality is known as the optimality condition, the second one as the
     complementarity condition.<br 
class="newline" />
     </p><!--l. 79--><p class="noindent" ><span 
class="ec-lmbx-10x-x-109">Important Remark 1</span>: Our implementation requires that initial point <span 
class="lmmi-10x-x-109">x</span><sub><span 
class="rm-lmr-8">0</span></sub> to be strictly
     feasible, ie: <span 
class="lmmi-10x-x-109">c</span><span 
class="rm-lmr-10x-x-109">(</span><span 
class="lmmi-10x-x-109">x</span><sub><span 
class="rm-lmr-8">0</span></sub><span 
class="rm-lmr-10x-x-109">) </span><span 
class="lmmi-10x-x-109">&#x003E; </span><span 
class="rm-lmr-10x-x-109">0</span>.<br 
class="newline" /><span 
class="ec-lmbx-10x-x-109">Important Remark 2</span>: The algorithm tries to find a pair (<span 
class="lmmi-10x-x-109">x</span>, <span 
class="lmmi-10x-x-109">&#x03BB;</span>) solving the Equations (<span 
class="lmmi-10x-x-109">P</span>),
     but this does not guarantee that <span 
class="lmmi-10x-x-109">x </span>is a global minimum of <span 
class="lmmi-10x-x-109">f </span>on the set <span 
class="lmsy-10x-x-109">{</span><span 
class="lmmi-10x-x-109">c</span><span 
class="rm-lmr-10x-x-109">(</span><span 
class="lmmi-10x-x-109">x</span><span 
class="rm-lmr-10x-x-109">) </span><span 
class="lmsy-10x-x-109">&#x2265; </span><span 
class="rm-lmr-10x-x-109">0</span><span 
class="lmsy-10x-x-109">}</span>.
</p>
     </li></ul>
                                                                                    

                                                                                    
<!--l. 1--><div class="crosslinks"><p class="noindent">[<a 
href="pnl-manualse13.html" >next</a>] [<a 
href="pnl-manualse11.html" >prev</a>] [<a 
href="pnl-manualse11.html#tailpnl-manualse11.html" >prev-tail</a>] [<a 
href="pnl-manualse12.html" >front</a>] [<a 
href="pnl-manual.html#pnl-manualse12.html" >up</a>] </p></div>
<!--l. 1--><p class="noindent" ><a 
 id="tailpnl-manualse12.html"></a> </p> 
</body></html> 
